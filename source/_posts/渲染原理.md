---
title: 渲染原理 #文章标题
date: 2018/12/20 23:46:25
updated: 2019/1/6 23:46:25
categories: "图形学" #文章分类目录 可以省略
tags: #文章标签 可以省略
     - 图形学
     - 渲染原理
description: #你对本页的描述 可以省略
---

# 渲染是什么？
渲染是CPU将数据交给GPU计算的过程。

## ``数据有哪些？``
- 模型参数：顶点，三角面，法线，切线，变换矩阵，UV，顶点色
- 材质参数：（颜色，纹理，金属的，粗糙度等）参数是动态的，可以是无限的。
+ 引擎内置参数：框架底层为每个shader声明的参数，框架底层为参数赋值（例如，深度缓冲，阴影缓冲）[通过变体等多种方式，可以理解为`固定参数`]
+ 全局参数：[`固定参数`]
- shader: 计算公式。  

我们可以这样理解: GPU 通过 `shader` 计算公式，带入参数（`模型参数` => `固定参数，上文列出，无论shader是否使用，都会传送到GPU` ，`材质参数` => `动态参数，任意个数和类型`），计算得出一张图片，这张图片就是渲染缓冲区（RenderTarget）。

**所以，只要shader和参数匹配，理论上我们可以通过添加无限的材质参数，来实现任意效果。**

<!-- more -->

## 我们所担忧的地方？
因为性能关系，我们希望shader尽可能复用：  
**只要`材质参数`相同，即参数个数相同，类型相同（因为材质参数和shader必须匹配，所以shader相同，个数和类型必定相同），``并且参数的值相同``，这样我们就能进行批处理,与`模型参数无关`（这是由GPU流水线，DX OPENGL，或者硬件架构决定的，具体由什么决定我不清楚）**，大大提升性能。

一个比喻性理解，可能不正确：一次渲染batch，就是用shader和`材质参数`一起搭建起一个渲染管道，shader是水管，`材质参数`就是连接头，搭建好以后，调用drawcall,`模型参数`顶点面片就是像水流流进管道，输出结果。如果多个模型shader和`材质参数`相同，那么不用重新搭建管道，可以一起输入多个模型，这就是批处理。

但这导致一个问题，多个模型使用相同的参数，那么看起来都一样（一样的金属光泽，一样的粗造度），太过单一。  

## 那能不能即保留多样性，同时又进行批处理呢？  

+ 如果想进行批处理：`材质参数`必须相同。
+ 如果想每个模型表现不同：shader 必须获得不同参数值。
  
## 我们由多种方法来达到这种效果(*^_^*)：
1. 将每个实例的参数封装到`模型参数`:模型参数支持8个UV，每个都是float4类型（uv012通常已经被使用），顶点色float4,通过这个方法将参数传递到shader。例如：使用顶点色R通道表示顶点受风力影响的强度。
2. 使用额外的缓冲区，可以是一张Texture,也可以是已经渲染完成Pass的结果。例如： ……
3. 全局参数：可以实多维数组使用模型坐标做Key设置好参数，shader中通过模型坐标取即可。

任何不通过`材质参数`将参数传递到shader的方法都可以。
